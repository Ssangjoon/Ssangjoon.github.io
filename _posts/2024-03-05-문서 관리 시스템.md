---
date: '2024-03-05 16:41:30 +0900'
categories:
  - Book
tags:
  - study
---
# 설계작업

## 임포터

세가지 형식의 문서를 다룬다. 

우편물은 .letter, 리포트는 .report, 이미지는 .jpg 인 전용 확장자를 사용. 

swtich문을 사용하면 하나의 메서드로 간단하게 구현이 가능하지만 확장성은 부족하다. 

다양한 문서를 임포트 하는 클래스로 분리하면, 각각의 임포트 동작을 따로 처리하므로 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다. 다양한 종류의 문서 임포트를 지원하도록 먼저 인터페이스를 정의한다. 

```java
public interface Importer {
    Document importFile(File file) throws IOException;
}
```

파일을 임포트할 인터페이스를 선언하였다. 파일은 어떻게 표현하는게 좋을까? 

파일 경로를 단순히 String으로 표현하거나  java.io.File처럼 파일을 가리키는 클래스를 사용한 다양한 방법이 있다. 

Importer 인터페이스의 파라미터로 java.io.File 객체를 사용해 임포트하는 파일을 기리킨다. 

하지만 반환타입은 Document로 지정해 두었다. 왜 FIle을 사용하지 않을까? 현재는 공개 API가 다른 종류의 사용자 인터페이스로 감싸진 상태이므로 어떤 파일을 지원해야 하는지 알 수 없다. 

## Document 클래스

이번엔 Document 클래스를 정의한다. 각 문서는 검색할 수 있는 다양한 속성을 포함한다. 문서의 종류에 따라 포함하는 속성이 달라진다. 

**간단하게 Map<String, String>으로 속성 이름을 값과 매핑하지 않는 이유가 뭘까?**

1. 강한 형식? 을 이용하면 데이터의 사용방법을 규제할 수 있다.
    - Document클래스는 불변 클래스, 즉 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없다. Importer 구현이 문서를 만들면 이후에 수정할 수 없는 것이다.
    - 따라서 Document의 속성에서 오류가 발생하면 해당 Document를 생성한 Importer 구현을 확인하면 되므로 오류가 발생한 원인을 좁힐 수 있다.
    - Document의 불변성 덕분에 안전하게 Document로 색인을 만들거나 정보를 캐시할 수 있다.
2. HashMap을 직접 상속 받으면 어떨까? 
    
    ```java
    public class Document extends HashMap<String, String> {
        
        public Document(Map<String, String> attributes) {
            super(attributes);
    }
    ```
    
    HashMap은 Document 모델링에 필요한 모든 기능을 포함한다 하지만, 설계 시점에서 필요한 기능은 추가하면서 동시에 불필요한 기능은 제한해야 한다. 
    
    Document클래스가 HashMap을 상속하면서 응용프로그램이 Document클래스를 바꿀 수 있도록 결정한다면 이전에 불변성으로 얻을 수 있는 이점이 사라진다. 
    

```java
public class Document {
    private final Map<String, String> attributes;

    Document(final Map<String, String> attributes) {
        this.attributes = attributes;
    }

    public String getAttribute(final String attributeName) {
        return attributes.get(attributeName);
    }
}
```

  요약하자면 도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한할 수 있다. Document는 오직 문서 관리 시스템에서만 만들 수 있어야 하므로 패키지 영역으로 생성자를 제공하고, 문서 관리 시스템이 위치한 패키지에만 접근 권한을 준다. 

## 임포터 구현과 등록

```java
class ImageImporter implements Importer {
    @Override
    public Document importFile(final File file) throws IOException {
        final Map<String, String> attributes = new HashMap<>();
        attributes.put(PATH, file.getPath());

        final BufferedImage image = ImageIO.read(file);
        attributes.put(WIDTH, String.valueOf(image.getWidth()));
        attributes.put(HEIGHT, String.valueOf(image.getHeight()));
        attributes.put(TYPE, "IMAGE");

        return new Document(attributes);
    }

}
```

```java
private final Map<String, Importer> extensionToImporter = new HashMap<>();

public DocumentManagementSystem() {
    extensionToImporter.put("letter", new LetterImporter());
    extensionToImporter.put("report", new ReportImporter());
    extensionToImporter.put("jpg", new ImageImporter());
}
```

# 리스코프 치환 원칙(LSP)

## 하위형식에서 선행조건을 더할 수 없음

선행 조건은 어떤 코드가 동작하는 조건을 결정한다. 우리는 구현한 코드가 어떻게든 실행 될 것이라고 가정할 수는 없다. 예를 들어 Importer의 구현은 임포트하려는 파일이 존재하며 읽을 수 있을 것이라는 선행조건을 갖는다. 따라서 Importer를 실행하기 전에 검증을 수행하는 메서드가 필요하다. 

```java
public void importFile(final String path) throws IOException {
        final File file = new File(path);
        if (!file.exists()) {
            throw new FileNotFoundException(path);
        }

        final int separatorIndex = path.lastIndexOf('.');
        if (separatorIndex != -1) {
            if (separatorIndex == path.length()) {
                throw new UnknownFileTypeException("No extension found For file: " + path);
            }
            final String extension = path.substring(separatorIndex + 1);
            final Importer importer = extensionToImporter.get(extension);
            if (importer == null) {
                throw new UnknownFileTypeException("For file: " + path);
            }

            final Document document = importer.importFile(file);
            documents.add(document);
        } else {
            throw new UnknownFileTypeException("No extension found For file: " + path);
        }
    }
```

LSP란 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다. 

## 하위형식에서 후행조건을 약화시킬 수 없음

후행조건은 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다. 예를 들어 유효한 파일에 importFile()을 실행했다면 contents()가 반환하는 문서 목록에 그 파일이 반드시 포함되어야 한다. 

즉, 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다. 

## 슈퍼형식의 불변자는 하위형식에서 보존됨

상속 관계의 부모와 자식 클래스가 있을 때, 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다. 

## 히스토리 규칙

기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다. 

# 기존 코드 확장과 재사용

## 유틸리티 클래스 사용

가장 간단한 방법이다. ImportUtil 클래스를 만들어 여러 임포트에서 공유해야 하는 기능을 이 클래스에 구현한다. 유틸리티 클래스는 결국 여러 정적 메서드를 포함한다. 

유틸리티 클래스는 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다. 시간이 흐를수록 이는 갓 클래스의 모양을 갖춰간다. 여러 의무를 담당하는 한 개의 거대한 클래스가 되어간다. 

## 상속 사용

그럼 어떻게 동작과 개념을 연결할 수 있을까? 상속을 이용할 수 있다. 각가의 임포터가 TextImporter클래스를 상속받는 방법이다. TextImporter 클래스에 모든 공통 기능을 구현하고 서브 클래스에서는 공통 기능을 재사용한다. 

리스코프 치환 원칙을 학습할 때 상속 관계에서 제약을 올바르게 추가하는 방법도 배웠다. 실제 관계를 상속으로 잘못 설정하는 상황도 종종 발생한다. 

이때 TextImporter는 Importer이며 이들은 LSP규칙을 따르지만 뭔가 허전하다. 

실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다는 점이 문제다. 시간이 흐르고 변경 사항이 생길 때, 응용프로그램을 그에 맞게 바꾸는 것보다는 변화를 추상화하는 것이 더 좋다. 

일반적으로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다. 

## 도메인 클래스 사용

마지막으로 도메인 클래스로 텍스트 파일을 모델링 하는 방법이 있다. 먼저 기본 개념을 모델링 하고, 기본 개념이 제공하는 메서드를 호출해 다양한 임포터를 만든다. 여기서 기본 개념이란? 

지금 상황에서는 텍스트 파일의 내용을 처리해야 하므로 TextFile 클래스를 사용한다. 

### 도메인 클래스 구현

```java
class TextFile {
    private final Map<String, String> attributes;
    private final List<String> lines;
...
```

TextFile 은 Document의 서브 클래스가 아니다. TextFile은 텍스트 파일이라는 기본 개념을 모델링하는 클래스로 텍스트 파일에서 데이터를 추출하는 메서드를 포함한다. 

도메인 클래스를 사용하면 상속같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다. 

```java
    @Override
    public Document importFile(final File file) throws IOException {
        final TextFile textFile = new TextFile(file);
        textFile.addLineSuffix(NAME_PREFIX, PATIENT);
        textFile.addLines(2, line -> false, BODY);

        final Map<String, String> attributes = textFile.getAttributes();
        attributes.put(TYPE, "REPORT");
        return new Document(attributes);
    }
```

처음엔 Importer 구현 내에 텍스트 추출 로직을 포함했었다. 여러 종류의 임포터 구현을 만들며 텍스트 추출 로직이 두 개의 임포터 에서 공유된다는 사실이 두드려졌고, 공통 도메인 개념을 기반으로 메서드를 호출할 수 있도록 TextFile 클래스를 만들었다.
