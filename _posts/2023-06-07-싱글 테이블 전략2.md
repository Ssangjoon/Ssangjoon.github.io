---
title: Embedded 타입과 엔티티 상속(정리중)
date: 2023-06-09 10:00:00 +0900
categories: [개인프로젝트]
tags: [GettingThingsDone,JPA]     # TAG names should always be lowercase
published: true
---
소셜 로그인 기능을 추가하면서 

일반 로그인 유저와 소셜 로그인 유저 테이블 관리를 어떻게 해야 하는지를 고민하게 되었다. 

두 테이블을 합치면 null 허용 컬럼이 많아질 듯하여 1대1관계로 설정하였으나 

어차피 따로 조회할 일이 많지 않다면 join하는 것보다 한테이블에 두는게 낫겠다 싶어서 다시 수정 한테이블에 관리하는 방향으로 바꾸었고, 

소셜 로그인 멤버의 컬럼을 따로 관리하는 방법을 찾다가
Entity 내부 연관 필드를 나타내는 `@Embedded` 방식과, 상속관계를 이용한 ***상속관계 전략***을 알게되었다. 

사용법은 크게 어렵지 않으나 차이점이 궁금해서 조사해봤다. 

# Embedded 타입

![https://m.blog.naver.com/qjawnswkd/222074105010](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/121852fc-4d81-485c-a56f-ca3c1310f132/Untitled.png)

https://m.blog.naver.com/qjawnswkd/222074105010

- Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메서드를 만들 수 있다.
- 임베디드 타입 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존
- `@AttributeOverride`를 활용하여 재사용 하기 용의하다.
- @AttributeOverride
    
    ```java
    @Embedded
    private Address homeAdress;
    @Embedded
    private Address workAdress;
    ```
    
    ```java
    @Embedded
    private Address homeAdress;
    @Embedded
    @AttributeOverrides({
    	@AttributeOverride(name = "city", column = @Colunm(name = "work_city")),
    	@AttributeOverride(name = "street", column = @Colunm(name = "work_street")),
    	@AttributeOverride(name = "zipcode", column = @Colunm(name = "work_zipcode")),
    })
    private Address workAdress;
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a9265d6d-1171-4972-abb2-dfbd2291e7ef/Untitled.png)
    

## 주의사항

```java
Address address = new Address("city","street","zipcode");
Member member1 = new Member();
member1.setHomeAdress(adress)
em.persist(member1);

Member member2 = new Member();
member1.setHomeAdress(adress)
em.persist(member2);

member1.getGetHomeAddress().setCity("newCity"); // 둘다 수정된다. 
```

같은 객체를 공유하기 때문에 모두 insert 문이 나간다. 

각각 수정가능하게 하려면 인스턴스를 복사해서 setHomeAddress에 넣어주면 될 것이다.

```java
Address address = new Address("city","street","zipcode");
Member member1 = new Member();
member1.setHomeAdress(adress);
em.persist(member1);

Address copyAddress = new Address(address.getCity(),address.getStreet(),address.getZipcode());

Member member2 = new Member();
member1.setHomeAdress(copyAddress);
em.persist(member2);

member1.getGetHomeAddress().setCity("newCity"); // member1만 수정됨
```

그러나 문제는 임베디드 타입처럼 직접 정의한 타입은 자바 기본 타입이 아니라 객체 타입?이다. 

객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다. 

**실수로 원본 Address객체를 member2에 넣는 것을 막을 방법은 없다는 이야기.**

<aside>
💡 **Embedded타입을 사용할 때는 불변 객체로 만들자.**

</aside>

# 상속관계 전략