---
title: 프론트 백이 분리된 이유 
date: 2023-07-05 00:00:30 +0900
categories: [개인프로젝트]
tags: [study, Curiosity]     # TAG names should always be lowercase
published: false
---
## Curiosity

프론트 엔드와 서버가 분리된 이유가 SPA 의 등장 덕분이라는게 이해가 가지 않았다.

동적으로 데이터를 받게 된 Ajax가 기준이 되어야 하지 않나? 라는 생각이 들었기 때문. 

한번 알아보자구

**서버(server)** : 클라이언트에게 네트워크를 통해 서비스하는 `컴퓨터`를 의미한다.

말그대로 어떤 요청을 원하는 대상에게 요청에 대한 응답을 넘겨주는 모든 것들을 (serve + er) `서버`라고 함.

## ****프론트엔드가 나온 이유****
<details>
<summary>자세히</summary>
<div markdown="1">       
- 자세히
    1. **문서 공유**를 위해 **WEB 1.0**이 만들어졌다.
    2. **CGI(Common Gate Interface) 통신**이 가능해졌다.
        
        정적인 정보만 담고 있던 문서에서 서버와 함께 동적인 페이지 생성이 가능하게 됨
        
    3. **Javascript의 탄생, 1995**
        
        브라우저에서 실행가능한 스크립트 언어의 탄생
        
    4. **문서를 예쁘게! 웹 디자인의 발전, CSS의 탄생, 1996**
        
        유지보수를 위해 컨텐츠와 서식을 분리하자는 CSS의 등장
        그리고 브라우저의 성능상 한계로 표현하지 못하던 애니메이션을 해결할 FLASH의 등장
        
    5. 검색엔진과 포털, e-커머스의 등장
    6. Internet Explore의 대중화와 웹의 상업화, 1995-2004
        
        솔루션 기반의 홈페이지가 대중화
        
        기능보다는 디자인, 웹 디자이너가 많이 생겨남
        
        HTML, CSS를 주로 다루던 웹 개발자는 천대받던 시절
        
    7. **Web 2.0과 RIA(Rich Web Application)**
        
        웹 기술을 통해 데스크탑 애플리케이션과 유사한 사용자 경험을 제공
        
        그리고 퇴출된 FLASH
        
    8. **구글 - 마이크로소프트의 대항마로 웹을 선택하다.**
        
        V8 자바스크립트 엔진의 등장
        
    9. **프론트엔드의 토대가 된 Ajax**
        
        자바스크립트를 통해 비동기로 화면을 동적으로 구성
        
    10. **웹 표준과 웹 접근성, 시맨틱.. 크로스 브라우징**
        
        W3C 웹 문서 작성 규약이 생기고 html, css, javascript를 통해 다양한 브라우저에서 동일하게 동작, 시각장애인도 웹 사용이 가능하게 접근성을 높인다
        
        좀 더 전문성을 요구하는 웹 개발
        
    11. **javascript 개발자를 찾습니다. jQuery의 등장!**
        
        웹표준 API를 포함하면서 쉬운 문법, IE 크로스브라우징, Ajax까지 해결한 jQuery의 탄생
        
        이때부터 프론트엔드에서 웹 디자이너와 웹 개발자의 영역이 조금 더 분리됨
        
        (크로스 브라우징, 시멘틱, 접근성) !== 디자이너의 영역
        
    12. **크롬브라우저와 V8엔진**
        
        javascript 성능을 개선하는 V8엔진 등장
        
        webkit + V8 = 크롬 브라우저 등장
        
        빠른 속도와 풍부한 디버깅 환경 제공
        
    13. **Node와 npm**
        
        javascript로 서버사이드 환경 개발 가능 (Node)
        
        module 방식의 개념의 보편화
        
    14. **페이스북 - 연결의 가치, 1분에 3테라의 데이터가 쌓인다**
        
        유래없는 단일 웹 서비스의 등장
        
    15. **백엔드와 프론트엔드의 각자의 전문성 분리, React의 탄생**
        
        php 확장 라이브러리를 기반으로 React를 개발
        
        React를 통해 더 나은 방식의 웹 개발 방식 등장
        
    16. **앞으로의 프론트엔드 방향성**
        
        보다 Serverless하게, 클라우드 서비스
        
        백엔드의 로직이 프론트로 점점 내려오고 백엔드는 데이터를 교환, 저장, 관리하는 인프라 영역으로 확대
        
        클라우드를 통해 서버없이 작업하는 형태로 발전 (서버 개발이 없다는 뜻)
</div>
</details>
        

js 등장 이후 계속 발전하였고, Ajax 등장으로 비동기적 데이터를 주고받는 개발이 가능해짐. 

jquery 등장과 함께 DOM 조작 및 이벤트 핸들링 등을 보다 쉽게 할 수 있게 되었고

구글의 V8엔진, Chrome 브라우저가 등장하고 나서 js 는 node.js 라는 서버 개발이 가능한 형태로 발전했고 범용적 언어가 됨. 

또한 module 방식의 보편화와 npm 생태계는 2010후반부터 js개발에서 널리 사용되기 시작되었으며, 이를 통해 JS 개발의 버전 관리 및 의존성 관리가 쉬워짐

페북 같은 거대한 단일 웹서비스 등장 이후 2010초반부터 기존과 다른 개발 방식으로 SPA와 관련된 프레임워크 및 라이브러리가 등장했으며, 이때부터 프론트엔드와 백엔드 개발 분리되어 웹 프로그램이 방식이 면화하게 되었다. 

## 백과 프론트의 분리

기존 MPA 에서 SPA 형태의 개발방식이 등장하였다. 

(단일 페이지에서 필요 데이터만 JSON 등의 형태로 전달 받아 동적 렌더링)

### 기존 방식 (SSR):

클라이언트 요청 → **서버에 존재하는 웹 어플리케이션이 데이터베이스 서버와 통신하여 필요한 데이터들을 전부 가져오고, 이것들을 가지고 완전한 HTML, CSS, JavaScript 파일들을 만들어서 클라이언트에게 제공**

클라이언트는 전달받은 파일들을 그대로 브라우저에서 사용하기만 하면 된다. 

### SPA (CSR):

![https://it-eldorado.tistory.com/85](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4318e7e4-1f5e-4024-b94f-fd65d12066b1/Untitled.png)


- **React, Vue, Angular 등은 JavaScript 라이브러리 혹은 프레임워크이다.** 
즉, 이것들은 클라이언트의 브라우저 단에서 실행되는 JavaScript를 멋지게 코딩할 수 있도록 도와주는 수단일 뿐이다
- 다만 이것들을 활용하면 프론트 엔드와 백 엔드를 완전히 구분하여 두 기능을 독립적으로 개발할 수 있게 된다
<details>
<summary>과정</summary>
<div markdown="1">       
    - 개발자가 React 라이브러리를 활용하여 클라이언트에게 제공할 JavaScript 파일들을 ES6 + JSX 문법으로 코딩한다.
    - Babel 등의 컴파일러가 그것들을 모든 브라우저에서 호환이 가능한 문법(ES5)의 코드로 변환해준다.
    - 또한 Webpack 등의 모듈 번들러가 HTML, CSS, JavaScript 파일들을 효율적인 방식으로 적절히 번들링 하여 준비해둔다.
    - create-react-app으로 생성한 React 프로젝트의 개발 환경에서는 "npm start"로 실행되는 개발 서버(webpack-dev-server)가 파일이 수정될 때마다 이러한 변환 작업들을 자동으로 수행해준다.
    - 그리고 실제 배포 시에는 번들링 한 파일들을 프론트 엔드 서버의 다큐먼트 루트에 미리 준비해두고 웹 서버가 그 파일들을 제공할 수 있도록 설정해야 한다.
    - 이후 클라이언트가 요청을 보내면 프론트 엔드 서버는 미리 준비해둔 HTML, CSS, JavaScript 파일들을 클라이언트에게 제공한다.
    - 그러면 클라이언트의 브라우저는 전달받은 JavaScript 파일을 실행하여 페이지에 렌더링을 시작한다.
</div>
</details>  

- **React 라이브러리를 활용하여 코딩했던 JavaScript 코드는 동적으로 DOM에 렌더링을 해주기 위한 코드**였던 것이다.
- 만약 렌더링 과정에서 DB 데이터가 필요한 경우에는 백 엔드 서버에게 API 요청을 보내서 필요한 데이터를 요청한다. 
이러한 맥락에서 **백 엔드 서버를 API 서버**라고 부르기도 한다. **필요한 데이터를 전달해주는 역할만 수행**할 뿐, 페이지 렌더링에 필요한 정적 리소스들을 제공해주는 것이 아니기 때문이다.
- 이후, 페이지를 리로드 하지 않고 부분적으로만 리렌더링이 필요해지는 경우에는 사용자의 버튼 클릭과 같은 액션을 감지하여 JavaScript가 마찬가지 방식으로 백 엔드 서버에게 API 요청을 보내게 된다.
- 이때는 딱 해당 부분의 리렌더링에 필요한 데이터만 요청하게 된다. 그러면 JavaScript가 그 응답 데이터를 가지고 필요한 부분만 리렌더링을 해주게 된다. 이것 또한 개발자가 React 라이브러리를 활용하여 미리 코딩해둔 JavaScript 코드의 역할인 것이다.

이러한 맥락에서 React, Vue, Angular 등을 **SPA(Single Page Application)**라고 부른다. **기본적인 HTML, CSS, JavaScript 파일들만 제공받은 다음에 렌더링이 필요한 부분에 대해서만 직접 백 엔드 서버에게 API 요청을 보내서 리렌더링을 하는 방식**이기 때문이다. 한 번 받은 페이지를 깜빡 거리는 일 없이 동적으로 제어가 가능해진다.

### **정리**

전통적인 SSR 방식에서는 서버에서 이미 거의 완벽히 그려진 HTML 페이지를 브라우저에게 전송한다. 별도의 JS 를 이용한 렌더링이 없다. thymeleaf가 사용되는 방식이 그 예

반면, CSR에서는 다 그려지지 않은 HTML 페이지가 브라우저에 보내지고 프론트엔드 프레임워크,js 를 이용해 나머지를 그린다. react를 이용한 렌더링이 그 예 

즉 클라이언트 사이드 렌더링이냐 서버사이드렌더링이냐의 차이

jsp나 thymeleaf 를 사용해본다면 알겠지만, controller에서 Model.addAtribute와 같은 함수로 서버에서 html로 데이터를 넘겨주며 HTML은 완성되고 렌더링된다. 
또한 controller에서 mapping에 따라 다른 HTML들은 return한다.(HTML이 여러개이다.multi-page-application(MPA)이다.)

반면 react에서는 index.html->index.js(Dom에 렌더링됨)->App.js와 같은 흐름으로 index.html에는 기본적인 틀만이 잡혀있고 index.js에 등록된 컴포넌트가 index.html위에 동적으로 렌더링된다. 
때문에 html은 index.html로 하나이고 요청에 따라 다양한 js들이 index.html에 올라옴으로써 화면이 전환된다.(HTML이 하나이다.single-page-application(SPA)이다.)

## **서버사이드vs클라이언트사이드 렌더링의 장단점**

- **서버사이드 렌더링(SSR)의 장점**
    
    검색엔진 최적화(SEO)적용이 용이
    
- **서버사이드 렌더링(SSR)의 단점**
    
    모든 요청에 대해 완전히 새페이지를 로딩,렌더링함(렌더링의 비효율)
    
    전체를 로딩하다보니 CSR보다 느리고,bandwidth를 많이씀. 동적인 렌더링에 불리.
    
- **클라이언트 렌더링(CSR)의 장점**
    
    바뀐 부분만 렌더링하므로 SSR보다 빠른 화면전환이 가능.
    
    lazy loading지원(중요하지 않은 리소스의 로딩을 늦춤)
    
    서버는 데이터만 보내주고 html을 그리는 역할은 클라이언트 측에 맡길 수 있음(서버 자원에 부담을 덜음)-> 프론트엔드와 백엔드의 분리
    
- **클라이언트 렌더링(CSR)의 단점**
    
    검색 노출에 불리(JS를 읽어 검색어에 반영하지 않으면 빈 html만을 검색어로 탐색)
    
    초기 구동속도가 느림(초기에 html을 다운 받고 각종 리소스,js를 다운,반영하기에)
    

## 프론트, 백엔드 분리 문제점 :

### CORS 이슈

- **CORS (Cross-Origin Resource Sharing)**
    
    추가 HTTP 헤더를 사용하여 브라우저에게 한 출처에서 실행중인 웹 응용 프로그램의 다른 출처의 선택된 자원에 대한 접근 권한을 알려주는 메커니즘
    

**기본적인 CORS 정책은 다른 오리진의 자원에 접근하는 것을 막는다**

프론트 , 백엔드를 분리해서 통신을 하게되면

각자 다른 컴퓨터가 서로 통신을 하는 것이기 때문에 따라서 백 엔드 서버에게 API 요청을 보내면 CORS 정책에 의해 요청이 거부당할 것이다.

이를 해결하려면 백 엔드 서버 쪽에서 CORS를 허용하기 위한 별도의 설정을 해줘야 한다.

### 쿠키 문제

- **오리진 (Origin)**
    
    **프로토콜, 도메인, 포트**를 합친 부분이다. 
    
    예를 들어, URL이 https://www.naver.com:8000/users/123이면 오리진은 https://www.naver.com:8000이다. 참고로, 서브 도메인이 있는 오리진과 없는 오리진은 다른 오리진으로 취급된다.
    

**다른 오리진에 대한 요청 시에는 쿠키를 전송 혹은 수신할 수 없다**

백 엔드 서버에게 API 요청을 보내더라도 쿠키가 설정되지 않기 때문에 로그인 등의 기능을 구현하는 것이 어려워진다. 

이를 해결하려면 백 엔드 서버에게 API 요청을 보낼 때 JavaScript 단에서 특정 설정(XMLHttpRequest.withCredentials 옵션을 true로 설정하거나, fetch API라면 credentials 옵션을 include로 설정)을 해줘야 하며, 

백 엔드 서버 쪽에도 응답의 헤더에서 Access-Control-Allow-Credentials 옵션을 true로 설정해줘야 한다.

한편 이것과 별개로 쿠키의 **SameSite** 옵션에도 주의를 기울여야 하는데, 기본적으로 Lax로 설정이 되기 때문에 GET 요청과 같은 안전한 요청이 아닌 이상 동일한 도메인일 때만 쿠키가 전송될 수 있다. 여기서 말하는 동일한 도메인이란 1차 도메인과 2차 도메인까지만을 말한다. 즉, a.naver.com과 b.naver.com은 동일한 도메인으로 취급된다.

## ???

SPA 방식 이전에도 프론트 백을 분리해서 사용했다고 한다. …

이 부분은 나중에 더 알아봐야 할 것 같다.

---

[https://velog.io/@kimtaeeeny/웹에서의-프론트-서버-백엔드-서버-개념-네트워크-study6](https://velog.io/@kimtaeeeny/%EC%9B%B9%EC%97%90%EC%84%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%84%9C%EB%B2%84-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%85%90-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-study6)

https://it-eldorado.tistory.com/85

[https://velog.io/@ttomy/서버사이드vs클라이언트사이드-렌더링과-react](https://velog.io/@ttomy/%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9Cvs%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81%EA%B3%BC-react)