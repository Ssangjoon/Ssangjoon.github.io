---
date: '2024-03-12 15:03:30 +0900'
categories:
  - Book
tags:
  - study
published: false
---
## 트우터 요구 사항

트우터는 **대중이 사용하는 응용프로그램**이다. 

사용자가 게시하는 각각의 마이크로블로그를 **트웃**이라 부르며 사용자는 연속적인 트웃 **스트림**을 갖는다. 다른 사용자를 **팔로우**해야 그 사용자가 무엇을 트우팅했는지 알 수 있다.

사람들의 원활한 의사소통을 시스템을 완성하기 위해 필요한 기능은 다음과 같다. 

- 고유의 사용자 ID와 비밀번호로 트우터에 로그인
- 각 사용자는 자신이 팔로우 하는 사용자 집합을 갖는다.
- 사용자는 트웃을 전송할 수 있으며 로그인한 이후로 게시된 팔로워의 모든 트웃을 볼 수 있다.
- 자신의 트웃을 삭제할 수 있다. 팔로워는 삭제된 트웃을 볼 수 없다.
- 사용자는 모바일이나 웹사이트로 로그인할 수 있다.

## 설계 개요

다양한 환경의 사용자가 어떻게 서로 통신할 수 있을까? 

보통 소프트웨어 개발자는 이런 문제를 **클라이언트 서버 모델**로 해결한다. 

**클라이언트** 그룹은 서비스를 사용하는 그룹이고 **서버는** 관련 서비스를 제공하는 그룹이다.

- 클라이언트 그룹
    - 서비스를 사용하는 그룹
    - 웹사이트나 스마트폰 응용프로그램
    - 트우터 서버와 통신하는 UI를 제공
- 서버 그룹
    - 관련 서비스를 제공하는 그룹
    - 대부분의 비즈니스 로직을 처리하며 다양한 클라이언트로부터 트웃을 받거나 전송

팔로워의 트웃을 즉시 볼 수 있어야한다.

사용자 인터페이스는 서버로 트웃을 전송할 뿐만 아니라 서버로부터 트웃을 받을 수 있어야 한다. 

### 풀 기반

풀 기반 통신에서는 **클라이언트가 서버로 정보를 요청**한다. 풀 기반 통신은 점대점 또는 요청 응답 통신 형식으로도 불린다. 대부분의 웹에서 이 통신 형식을 사용한다. 

### 푸시 기반

이를 **리액티브 또는 이벤트 주도통신**이라고도 부른다. 푸시 기반 모델에서는 **작성자가 방출한 이벤트 스트림을 여러 구독자가 수신한다**. 따라서 이 모델은 일대일 통신뿐만 아니라 **다대다 통신도 지원**한다. 푸시 기반 통신은 여러 컴포넌트 간에 다양한 이벤트의 의사소통이 발생하는 상황에서 특히 유용하다. 

트우터에서는 이벤트 주도 형식이 적합하다. 이 모델에서 이벤트는 트웃이다. (물론 요청 응답 통신 형식으로도 응용프로그램을 설계할 수 있다. )

하지만 사용자가 ‘지난 데이터를 요청한 이후로 누군가 트웃을 날린 사용자가 있나요?’ 라고 물으면 서버에서 정기적으로 데이터를 요청해야 한다. 이벤트 주도 형식에서는 다른 사용자를 팔로우, 즉 이벤트를 구독하면 사용자가 구독한 관심 트웃을 서버가 클라이언트로 푸시한다. 

## 이벤트에서 설계까지

지금은 클라이언트보다 서버 컴포넌트에 집중한다. 

### 통신

이벤트를 전송하고 수신하는 기능을 어떤 기술로 구현할지를 설계할 차례다. 

- **웹소켓은** TCP 스트림으로 양방향 이벤트 통신을 지원하는 가벼운 통신 프로토콜이다.
    - 최신 브라우저 지원하는 웹 서버와 웹 브라우저 사이의 이벤트 주도 통신에 주로 사용된다.
- 아마존의 단순 큐 서비스같은 호스트된 **클라우드 기반 메시지 큐**를 메시지 송출이나 수신에 점점 많이 사용한다.
    - 메시지 큐는 그룹 내의 프로세스 중 한 프로세스가 전송된 메시지를 받아 처리하는 상호 프로세스 통신 방식이다.
- 다양한 통신 방식을 혼합할 수도 있다. 예를 들어 클라이언트 종류에 따라 다른 통신 기술을 사용하는 방식이다.
    - 웹 사이트와는 웹 소켓, 안드로이드 모바일 앱과는 푸시 노티피케이션으로 통신하는 것도 가능할 것이다.

### GUI

UI 통신 기술이나 UI를 서버의 비즈니스 로직과 결합하려면 몇 가지 단점이 발생한다. 

- 테스트하기 어렵고 테스트 실행도 느려진다. 모든 테스트가 실행중인 메인 서버로 이벤트를 발행하거나, 수신해야 하기 때문이다.
- 단일 책임 원칙을 위반한다.

결론적으로 메시징을 코어 비즈니스 로직과 분리할 수 있도록 추상화해야 한다. 즉 클라이언트에게 메시지를 전송하고 클라이언트의 메시지를 수신하는 인터페이스가 필요하다. 

### 영구저장

- **직접 인덱스하고 검색할 수 있는 일반 텍스트 파일** : 기록된 데이터를 쉽게 볼 수 있으며 다른 응용프램과의 디펜던시를 줄일 수 있다.
- **전통적 SQL 데이터베이스** :
- **NoSQL 데이터베이스** : 다양한 유스 케이스, 질의 언어, 데이터 저장 모델을 지원하는 여러 데이터베이스가 있다.

시작 단계에서 어떤 기술이 적합한지 선택하기가 어려울 뿐만 아니라 시간이 흐르면서 요구 사항은 계속 바뀐다. 저장소 백엔드가 응용 프로그램의 다른 부분과 결합하지 않도록 설계하고 싶다. 

어떤 기능이 특정 기술과 결합하지 않도록 방지하는 일은 개발자가 흔히 하는 문제중 하나다. 

### 육각형 아키텍처

앨리스터 콕번이 정립한 **포트와 어댑터** 또는 **육각형 아키텍처**라 불리는 조금 더 일반화된 아키텍처를 적용해 이 문제를 해결할 수 있다.

![육각형 아키텍처]({{site.baseurl}}/assets/img/화면 캡처 2024-03-11 150643.png)

이 아키텍처에서 응용프로그램의 코어는 우리가 구현하는 비즈니스 로직이고, 다양한 구현은 코어 로직으로부터 분리되어 있음을 보여준다. 

코어 비즈니스 로직과 분리하려는 특정 기술이 있다면 **포트**를 이용한다. 
외부 이벤트는 포트를 통해 코어 비즈니스 로직으로 전달된다.  **어댑터**는 포트로 연결하는 특정 기술을 이용한 구현 코드다.

## 작업 순서

이제 설계를 더 구체화하고 다이어그램을 세부적으로 완성하면서 어떤 클래스로 무슨 기능을 구현할지 결정할 차례다. 

```java
@Test
public void shouldBeAbleToAuthentiateUser(){
    // 유효 사용자의 로그온 메시지 수신
    // 로그온 메서드는 새 엔드포인트 반환
    // 엔드포인트 유효성을 확인하는 어서션
}
```

테스트를 구현하려면 `Twootr` 클래스를 만들고 로그인 이벤트를 모델링해야 한다. 이 모듈에서는 발생한 이벤트에 대응하는 모든 메서드명 앞에 on을 붙이는 규칙을 정한다. 

즉 우리는 `onLogon`이라는 메서드를 구현할 것이다. 이 메서드는 메서드 시그니처를 어떻게 정의해야 할까? 

이미 포트로 아키텍처 결정과 UI 통신을 분리했으니 API를 어떻게 정의할지 결정해야 한다. 

사용자에게 이벤트를 발송하는 기능이 필요하다. 또한 사용자가 이벤트를 수신하는 기능도 필요하다. 

**포트와 어댑터의 목표는 응용프로그램의 코어와 특정 어댑터 구현의 결합을 제거하는 것이다. 즉 인터페이스로 다양한 어댑터를 추상화해야 한다.** 

사용자의 이벤트를 발행하는 객체의 구현은 코어에  한 개뿐이므로 인터페이스가 아닌 일반 클래스로 구현한다. 지금까지의 설계를 확인해보자.

![이벤트를 코드로.png]({{site.baseurl}}/assets/img/이벤트를 코드로.png)


이벤트를 전송하고 수신하는 API의 이름을 정해야 한다. 

이벤트를 코어로 보내는 `SenderEndPoint`클래스와 코어로부터 이벤트를 수신하는 인터페이스를 `ReceiverEndPoint`라는 이름으로 정했다. 

이제 `shouldBeAbleToAuthentiateUser()` 테스트를 구현한다. 유효한 사용자명으로 로그인했을 때 성공적으로 인증되는지 확인한다. 

사용자가 로그인하면 UI로 유효한 `SenderEndPoint`객체(사용자를 대표하는 객체)를 반환한다.

그리고 로그인 이벤트가 발생했으며 테스트 코드가 컴파일 되도록 Twootr 클래스에 메서드를 추가 해야한다.    

```java
Optional<SenderEndPoint> onLogon( String userId, ReceiverEndPoint receiverEndPoint) {}
```

```java
@Test
public void shouldNotAuthenticateUserWithWrongPassword()
{
    final Optional<SenderEndPoint> endPoint = twootr.onLogon(
            TestData.USER_ID, "bad password", receiverEndPoint);

    assertFalse(endPoint.isPresent());
}
```

사용자는 도메인의 중요한 개념이다. 사용자 ID를 키로, 사용자를 가리키는 User객체를 값으로 갖도록한다. 

## 비밀번호와 보안

트우터는 바운시 캐슬이라는 유명한 자바 라이브러리를 사용한다. 

```java
class KeyGenerator {
    private static final int SCRYPT_COST = 16384;
    private static final int SCRYPT_BLOCK_SIZE = 8;
    private static final int SCRYPT_PARALLELISM = 1;
    private static final int KEY_LENGTH = 20;

    private static final int SALT_LENGTH = 16;

    private static final SecureRandom secureRandom = new SecureRandom();

    static byte[] hash(final String password, final byte[] salt) {
        final byte[] passwordBytes = password.getBytes(UTF_16);
        return SCrypt.generate(
            passwordBytes,
            salt,
            SCRYPT_COST,
            SCRYPT_BLOCK_SIZE,
            SCRYPT_PARALLELISM,
            KEY_LENGTH);
    }

    static byte[] newSalt() {
        final byte[] salt = new byte[SALT_LENGTH];
        secureRandom.nextBytes(salt);
        return salt;
    }
}
```

무차별 대입으로 특정 길이 이내의 키를 맞추거나 레인보 테이블로 해싱된 값을 되돌릴 수 있다는 점이 약점이다. 

**솔트**로 이를 방지할 수 있다. 솔트란 암호 해싱 함수에 적용하는 임의로 생성된 추가 입력이다. 사용자가 입력하지 않은 임의의 값을 비밀번호에 추가해 누군가 해싱을 되돌리는 기능을 만들지 못하게 막는다. 해싱을 되돌리려면 해싱 함수와 솔트, 이 두 가지를 모두 알아야 하기 때문!!. 

저장된 데이터 뿐만 아니라 전송되는 데이터의 보안도 신경써야 한다. 클라이언트가 서버로 접속했을 때 사용자의 비밀번호를 연결된 네트워크로 전송해야 한다. 악의적인 해커가 연결을 가로챌수있기 때문.

트우터는 웹소켓으로 로그인 메시지를 받는다. 즉 중간자 공격(man-in-the-middle-attack)으로 부터 웹 소켓 연결을 안전하게 지켜야 한다. 다양한 방법이 있지만 가장 흔하면서도 단순한 방법은 전송 계층 보안 Transport Layer Security(TLS), 즉 연결된 네트워크로 전달되는 데이터의 프라이버시와 연결성을 제공하는 암호화된 프로토콜을 사용하는 것이다.
