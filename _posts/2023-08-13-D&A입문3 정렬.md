---
title: D&A3 정렬
date: 2023-08-13 00:00:30 +0900
categories: [DataStructure & Algorithme, 정렬]
tags: [study, DataStructure & Algorithme]     # TAG names should always be lowercase
published: true
---

# 개요

- 정렬 알고리즘의 안정성
    - 정렬 알고리즘은 안정된 알고즘과 그렇지 않은 알고리즘으로 나눌 수 있다.
        - 안정성이란 키와 값 쌍을 가진 객체들 중 같은 키를 가진 객체드르이 순서가 정렬이후에도 유지 되는 것.
- 내부 정렬과 외부 정렬
    - 내부 : 정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때 사용
    - 외부 : 데이터가 많아서 하나의 배열에 저장할 수 없을 때 사용
- 정렬 알고리즘의 핵심 요소
    - 교환
    - 선택
    - 삽입

# 버블 정렬

- 이웃한 두 요소의 대소관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘
- 단순 교환 정렬(straight exchange sort)라고도 부른다.

<details>
<summary>버블 정렬 O(n^2)</summary>
<div markdown="1">

- 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘.
    - 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
- 선택정렬과 기본개념이 비슷

### 구체적인 개념

- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

### 예제
![bubbleSort](/assets/img/bubbleSort.png)


시간복잡도는  O(n^2) 효율성 나타냄

https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html
</div>
</details>

# 단순 선택 정렬

- 가장 작은 요소를 맨 앞으로 이동하고, 두 번째 요소는 맨 앞에서 두 번째로 이동하는 작업을 반복하는 알고리즘
    - 아직 정렬하지 않은 부분에서 가장 작은 값을 선택
    - 아직 정렬하지 않은 부분의 첫 번쨰 요소를 교환
- 떨어져 있던 요소들을 교환하는 방식이므로 안정적이지 않은 알고리즘에 속한다.

<details>
<summary>선택 정렬 O(n^2)</summary>
<div markdown="1">

- 제자리 정렬(in-place sorting) 알고리즘의 하나
    - 입력 배열 (정렬되지 않은 값들)이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
- 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
    - 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
    - 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값
    - …
- 과정 설명
    - 주어진 배열 중에서 최솟값을 찾는다.
    - 그 값을 맨 앞에 위치한 값과 교체한다.
    - 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
    - 하나의 원소만 남을 때 까지 위의 과정을 반복한다.

### 구체적인 개념

- 선택 정렬은 첫 번째 값을 두 번째부터 마지막 값 까지 차례대로 비교하여 최솟값을 찾아 첫 번째에 놓고, 두 번째 값을 세 번째부터 마지막 값까지 비교하여 최솟값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬하는 알고리즘.
- 1 회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.

### 예제
![selectionSort](/assets/img/insertSort.png)


시간복잡도는 O(n^2)

</div>
</details>

# 단순 삽입 정렬

- 단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 ‘삽입하는’작업을 반복하여 정렬하는 알고리즘
    - 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬한 부분의 알맞은 위치에 삽입한다.
    - 알맞은 위치에 삽입한다는 말은 왼쪽에 이웃한 요소가 크면 앞으로 이동하는 작업을 반복 하는 것을 말한다
    
    ```java
    // 단순 삽입 정렬
    
    import java.util.Scanner;
    
    class InsertionSort {
        //--- 단순 삽입 정렬 ---//
        static void insertionSort(int[] a, int n) {
            for (int i = 1; i < n; i++) {
                int j;
                int tmp = a[i];
                for (j = i; j > 0 && a[j - 1] > tmp; j--)
                    a[j] = a[j - 1];
                a[j] = tmp;
            }
        }
    
        public static void main(String[] args) {
            Scanner stdIn = new Scanner(System.in);
    
            System.out.println("단순 삽입 정렬");
            System.out.print("요솟수: ");
            int nx = stdIn.nextInt();
            int[] x = new int[nx];
    
            for (int i = 0; i < nx; i++) {
                System.out.print("x[" + i + "] : ");
                x[i] = stdIn.nextInt();
            }
    
            insertionSort(x, nx);        // 배열 x를 단순삽입정렬
    
            System.out.println("오름차순으로 정렬했습니다.");
            for (int i = 0; i < nx; i++)
                System.out.println("x[" + i + "]=" + x[i]);
        }
    }
    ```
    
    - 서로 떨어져 있는 요소들을 교환하는 것이 아니므로 안정적이다.
<details>
<summary>삽입 정렬 O(n^2)~O(n)</summary>
<div markdown="1">

- 손 안의 카드를 정렬하는 방법과 유사하다.
    - 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.
    - 새로 삽입될 카드의 수만큼 반복하게 되면 전체카드가 정렬된다.
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.

### 구체적인 개념

- 삽입 정렬은 두 번째 값부터 시작해 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
- 즉, 두 번째 자료는 첫 번째 자료, 세번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세번째, 두번째, 첫번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동 시킨다.
- **처음 key 값은 두 번째 자료부터 시작한다**.

### 예제
![insertSort](/assets/img/selectSort.png)


평균 시간복잡도는 O(n^2)이며, Best Case 의 경우 O(n)까지 높아질 수 있습니다.


</div>
</details>
# 단순 정렬의 시간복잡도

버블 정렬, 선택 정렬, 삽입 정렬의 시간 복잡도는 모두 O(n^2)이다.

효율이 좋지 않다. 

# 셸 정렬

셸 정렬은 **단순 삽입 정렬의 장점을 살리고 단점을 보완**하여 좀 더 **빠르게** 정렬하는 알고리즘

단순 삽입 정렬의 경우 정렬이 되어 있을 수록 빠르고, 삽입할 곳이 멀리 떨어져 있다면 이동하는 횟수가 많아진다. 

**셸 정렬은** 

- 먼저 일정한 간격으로 서로 떨어져 있는 두 요소를 그룹으로 묶어 대략 정렬을 수행하고,
- 간격을 좁혀 그룹의 수를 줄이면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.